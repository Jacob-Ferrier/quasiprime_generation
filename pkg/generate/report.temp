import (
	"fmt"
	"time"
)

func report() {
	var completeQuasiprimeList QuasiprimeList

	completeModuloDataList := make(map[int]map[int]moduloData, moduloMax-1)
	for m := 2; m <= moduloMax; m++ {
		completeModuloDataList[m] = make(map[int]moduloData, m)
		for p := 0; p < m; p++ {
			completeModuloDataList[m][p] = moduloData{0, 0.0}
		}
	}

	completeNumQuasiprimes := 0
	for u := range singleC {
		for r := 0; r < len(completeModuloDataList); r++ {
			completeModuloDataList[r] = moduloData{completeModuloDataList[r].quantity + u[r].quantity, 0.0}
			completeNumQuasiprimes += u[r].quantity
		}
	}

	var completeGenerationTime time.Duration
	for x := range timeC {
		completeGenerationTime += x
	}

	completeQuasiprimeList.modulo = modulo
	completeQuasiprimeList.nQuasiprime = nQuasiprime
	completeQuasiprimeList.outFileName = fmt.Sprintf("%s/%v-quasiprimes.modulo%v.complete_report.txt", outputDir, nQuasiprime, modulo)
	completeQuasiprimeList.minIntegerChecked = 0
	completeQuasiprimeList.maxIntegerChecked = maxNumberToGen
	completeQuasiprimeList.numIntergersChecked = maxNumberToGen + 1
	completeQuasiprimeList.numQuasiprimes = completeNumQuasiprimes
	completeQuasiprimeList.quasiprimeGenerationTime = completeGenerationTime

	for y := 0; y < len(completeModuloDataList); y++ {
		percentage := float64(completeModuloDataList[y].quantity) / float64(completeQuasiprimeList.numQuasiprimes)
		completeModuloDataList[y] = moduloData{completeModuloDataList[y].quantity, percentage}
	}

	completeQuasiprimeList.moduloDataList = completeModuloDataList

	coll := make(map[int]map[int]quasiprime, len(quasiprimeC))
	mins := make(map[int]int, len(quasiprimeC))
	order := make(map[int]int, len(quasiprimeC))
	i := 0
	for u := range quasiprimeC {
		coll[i] = u
		mins[i] = u[0].number
		order[i] = i
		i++
	}

	for j := 0; j < len(order)-1; j++ {
		swapped := false
		for k := 0; k < len(order)-1; k++ {
			if mins[order[k]] > mins[order[k+1]] {
				temp := order[k]
				order[k] = order[k+1]
				order[k+1] = temp
				swapped = true
			}
		}

		if !swapped {
			break
		}
	}

	completeQuasiprimes := make(map[int]quasiprime, completeQuasiprimeList.numQuasiprimes)
	k := 0
	for i := 0; i < len(order); i++ {
		for j := 0; j < len(coll[order[i]]); j++ {
			completeQuasiprimes[k] = coll[order[i]][j]
			k++
		}
	}

	completeQuasiprimeList.quasiprimes = completeQuasiprimes
	completeQuasiprimeList.minQuasiprime = completeQuasiprimeList.quasiprimes[0].number
	completeQuasiprimeList.maxQuasiprime = completeQuasiprimeList.quasiprimes[completeQuasiprimeList.numQuasiprimes-1].number

	completePairedModuloDataList := make(map[int]map[int]moduloData, completeQuasiprimeList.modulo)
	for a := 0; a < modulo; a++ {
		completePairedModuloDataList[a] = make(map[int]moduloData, completeQuasiprimeList.modulo)
		for b := 0; b < modulo; b++ {
			completePairedModuloDataList[a][b] = moduloData{}
		}
	}
	completeQuasiprimeList.pairedModuloDataList = completePairedModuloDataList

	totalPairs := 0
	for i := 0; i < len(completeQuasiprimeList.quasiprimes)-1; i++ {
		q, n := completeQuasiprimeList.quasiprimes[i], completeQuasiprimeList.quasiprimes[i+1]

		completeQuasiprimeList.pairedModuloDataList[q.moduloResult][n.moduloResult] =
			moduloData{completeQuasiprimeList.pairedModuloDataList[q.moduloResult][n.moduloResult].quantity + 1, 0.0}

		totalPairs++
	}

	for a := 0; a < len(completeQuasiprimeList.pairedModuloDataList); a++ {
		for b := 0; b < len(completeQuasiprimeList.pairedModuloDataList[a]); b++ {
			completeQuasiprimeList.pairedModuloDataList[a][b] = moduloData{completeQuasiprimeList.pairedModuloDataList[a][b].quantity,
				float64(completeQuasiprimeList.pairedModuloDataList[a][b].quantity) / float64(totalPairs)}
		}
	}

	completeQuasiprimeList.writeToFile(false, true)
}
